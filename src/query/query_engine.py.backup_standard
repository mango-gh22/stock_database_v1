#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
查询引擎 - v0.4.0（标准化版）
使用标准列名：open, high, low, close 等
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Union, Tuple
from datetime import datetime, timedelta
from sqlalchemy import text
from src.database.connection import engine
from src.utils.logger import get_logger

logger = get_logger(__name__)

class QueryEngine:
    """股票数据查询引擎（标准化版）"""

    def __init__(self, config_path: str = None):
        self.engine = engine
        self.logger = get_logger(__name__)
        self.table_name = 'stock_daily_data'  # 自动选择表
        self._init_cache()

    def _init_cache(self):
        self._stock_cache = {}
        self._index_cache = {}

    def _execute_query(self, query: str, params: dict = None) -> pd.DataFrame:
        try:
            if params:
                df = pd.read_sql_query(text(query), self.engine, params=params)
            else:
                df = pd.read_sql_query(text(query), self.engine)
            return df
        except Exception as e:
            self.logger.error(f"执行查询失败: {e}")
            return pd.DataFrame()

    def get_daily_data(self,
                      symbol: str = None,
                      start_date: str = None,
                      end_date: str = None,
                      fields: List[str] = None,
                      limit: int = None) -> pd.DataFrame:
        """
        查询日线行情数据（使用标准列名）
        """
        # 默认字段（标准列名）
        if fields is None:
            fields = [
                'trade_date', 'symbol', 'open', 'high', 'low', 'close',
                'volume', 'amount', 'pct_change', 'change',
                'pre_close', 'turnover_rate', 'amplitude'
            ]

        field_str = ', '.join(fields)

        query = f"""
        SELECT {field_str}
        FROM {self.table_name}
        WHERE 1=1
        """
        params = {}

        if symbol:
            query += " AND symbol = :symbol"
            params['symbol'] = symbol
        if start_date:
            query += " AND trade_date >= :start_date"
            params['start_date'] = start_date
        if end_date:
            query += " AND trade_date <= :end_date"
            params['end_date'] = end_date

        query += " ORDER BY trade_date DESC"

        if limit:
            query += f" LIMIT {limit}"

        try:
            df = self._execute_query(query, params)

            if not df.empty and 'trade_date' in df.columns:
                df['trade_date'] = pd.to_datetime(df['trade_date'])
                df = df.sort_values('trade_date')

            self.logger.info(f"查询日线数据，返回{len(df)}条记录")
            return df

        except Exception as e:
            self.logger.error(f"查询日线数据失败: {e}")
            return pd.DataFrame()

    # 其他方法保持不变...
    def get_stock_basic(self, 
                       symbol: str = None,
                       exchange: str = None,
                       industry: str = None) -> pd.DataFrame:
        query = """
        SELECT 
            symbol, stock_name as name, exchange, industry, 
            listing_date, is_active, created_at
        FROM stock_basic_info
        WHERE 1=1
        """
        params = {}

        if symbol:
            query += " AND symbol = :symbol"
            params['symbol'] = symbol
        if exchange:
            query += " AND exchange = :exchange"
            params['exchange'] = exchange
        if industry:
            query += " AND industry LIKE :industry"
            params['industry'] = f"%{industry}%"

        query += " ORDER BY symbol"

        try:
            df = self._execute_query(query, params)
            self.logger.info(f"查询股票基本信息，返回{len(df)}条记录")
            return df
        except Exception as e:
            self.logger.error(f"查询股票基本信息失败: {e}")
            return pd.DataFrame()

    def get_data_statistics(self) -> Dict:
        stats = {}

        # 股票数量统计
        stock_query = """
        SELECT 
            COUNT(*) as total_stocks,
            COUNT(DISTINCT industry) as total_industries,
            exchange,
            COUNT(*) as count_by_exchange
        FROM stock_basic_info
        GROUP BY exchange
        """

        # 日线数据统计
        daily_query = f"""
        SELECT 
            COUNT(*) as total_records,
            MIN(trade_date) as earliest_date,
            MAX(trade_date) as latest_date,
            COUNT(DISTINCT symbol) as stocks_with_data
        FROM {self.table_name}
        """

        try:
            stock_stats = pd.read_sql_query(text(stock_query), self.engine)
            daily_stats = pd.read_sql_query(text(daily_query), self.engine)

            stats['stock_basic'] = {
                'total_stocks': int(stock_stats['total_stocks'].iloc[0]) if len(stock_stats) > 0 else 0,
                'total_industries': int(stock_stats['total_industries'].iloc[0]) if len(stock_stats) > 0 else 0,
                'exchange_distribution': stock_stats.set_index('exchange')['count_by_exchange'].to_dict()
            }

            stats['daily_data'] = {
                'total_records': int(daily_stats['total_records'].iloc[0]) if len(daily_stats) > 0 else 0,
                'earliest_date': str(daily_stats['earliest_date'].iloc[0]) if len(daily_stats) > 0 else None,
                'latest_date': str(daily_stats['latest_date'].iloc[0]) if len(daily_stats) > 0 else None,
                'stocks_with_data': int(daily_stats['stocks_with_data'].iloc[0]) if len(daily_stats) > 0 else 0
            }

            self.logger.info("数据统计查询成功")
            return stats

        except Exception as e:
            self.logger.error(f"数据统计查询失败: {e}")
            return {}

    def get_stock_list(self) -> List[str]:
        query = "SELECT symbol FROM stock_basic_info ORDER BY symbol"
        try:
            df = pd.read_sql_query(text(query), self.engine)
            return df['symbol'].tolist()
        except Exception as e:
            self.logger.error(f"获取股票列表失败: {e}")
            return []

    def test_connection(self) -> bool:
        try:
            with self.engine.connect() as conn:
                result = conn.execute(text("SELECT 1"))
                self.logger.info("数据库连接测试成功")
                return True
        except Exception as e:
            self.logger.error(f"数据库连接测试失败: {e}")
            return False

    def close(self):
        pass

if __name__ == "__main__":
    engine = QueryEngine()
    stats = engine.get_data_statistics()
    print(f"数据统计: {stats}")
    engine.close()
