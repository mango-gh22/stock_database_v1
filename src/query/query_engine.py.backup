# _*_ coding: utf-8 _*_
# File Path: E:/MyFile/stock_database_v1/src/query\query_engine.py
# File Name: query_engine
# @ Author: m_mango
# @ Dateï¼š2025/12/6 16:26
"""
desc 3.1 æŸ¥è¯¢å¼•æ“æ ¸å¿ƒç±»
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
æŸ¥è¯¢å¼•æ“ - v0.4.0ï¼ˆSQLAlchemyç‰ˆæœ¬ï¼‰
ä½œè€…ï¼šæ‚¨çš„GitHubç”¨æˆ·å
æ—¥æœŸï¼š2024-12-06
åŠŸèƒ½ï¼šè‚¡ç¥¨æ•°æ®æŸ¥è¯¢æ ¸å¿ƒå¼•æ“
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Union, Tuple
from datetime import datetime, timedelta
from sqlalchemy import text
from src.database.connection import get_session, engine
from src.utils.logger import get_logger

logger = get_logger(__name__)


class QueryEngine:
    """è‚¡ç¥¨æ•°æ®æŸ¥è¯¢å¼•æ“ï¼ˆSQLAlchemyç‰ˆæœ¬ï¼‰"""

    def __init__(self, config_path: str = None):
        """
        åˆå§‹åŒ–æŸ¥è¯¢å¼•æ“

        Args:
            config_path: é…ç½®æ–‡ä»¶è·¯å¾„
        """
        self.engine = engine
        self.logger = get_logger(__name__)
        self._init_cache()

    def _init_cache(self):
        """åˆå§‹åŒ–ç¼“å­˜"""
        self._stock_cache = {}
        self._index_cache = {}

    def _execute_query(self, query: str, params: dict = None) -> pd.DataFrame:
        """
        æ‰§è¡ŒSQLæŸ¥è¯¢

        Args:
            query: SQLæŸ¥è¯¢è¯­å¥
            params: æŸ¥è¯¢å‚æ•°

        Returns:
            DataFrame: æŸ¥è¯¢ç»“æœ
        """
        try:
            if params:
                df = pd.read_sql_query(text(query), self.engine, params=params)
            else:
                df = pd.read_sql_query(text(query), self.engine)
            return df
        except Exception as e:
            self.logger.error(f"æ‰§è¡ŒæŸ¥è¯¢å¤±è´¥: {e}")
            self.logger.error(f"æŸ¥è¯¢è¯­å¥: {query}")
            self.logger.error(f"æŸ¥è¯¢å‚æ•°: {params}")
            return pd.DataFrame()

    def get_stock_basic(self,
                       symbol: str = None,
                       exchange: str = None,
                       industry: str = None) -> pd.DataFrame:
        """
        æŸ¥è¯¢è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯

        Args:
            symbol: è‚¡ç¥¨ä»£ç ï¼ˆå¦‚ï¼š000001.SZï¼‰
            exchange: äº¤æ˜“æ‰€ï¼ˆSZ/SHï¼‰
            industry: è¡Œä¸šåˆ†ç±»

        Returns:
            DataFrame: è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯
        """
        query = """
        SELECT 
            symbol, name, exchange, industry, 
            listing_date, is_active, created_at
        FROM stock_basic
        WHERE 1=1
        """
        params = {}

        if symbol:
            query += " AND symbol = :symbol"
            params['symbol'] = symbol
        if exchange:
            query += " AND exchange = :exchange"
            params['exchange'] = exchange
        if industry:
            query += " AND industry LIKE :industry"
            params['industry'] = f"%{industry}%"

        query += " ORDER BY symbol"

        try:
            df = self._execute_query(query, params)
            self.logger.info(f"æŸ¥è¯¢è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯ï¼Œè¿”å›{len(df)}æ¡è®°å½•")
            return df
        except Exception as e:
            self.logger.error(f"æŸ¥è¯¢è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯å¤±è´¥: {e}")
            return pd.DataFrame()

    def get_daily_data(self,
                      symbol: str = None,
                      start_date: str = None,
                      end_date: str = None,
                      fields: List[str] = None,
                      limit: int = None) -> pd.DataFrame:
        """
        æŸ¥è¯¢æ—¥çº¿è¡Œæƒ…æ•°æ®

        Args:
            symbol: è‚¡ç¥¨ä»£ç 
            start_date: å¼€å§‹æ—¥æœŸï¼ˆYYYY-MM-DDï¼‰
            end_date: ç»“æŸæ—¥æœŸï¼ˆYYYY-MM-DDï¼‰
            fields: è¿”å›å­—æ®µåˆ—è¡¨
            limit: æœ€å¤§è¿”å›æ¡æ•°

        Returns:
            DataFrame: æ—¥çº¿è¡Œæƒ…æ•°æ®
        """
        # é»˜è®¤å­—æ®µ
        if fields is None:
            fields = ['trade_date', 'symbol', 'open', 'high', 'low',
                     'close', 'volume', 'amount', 'change', 'pct_change']

        field_str = ', '.join(fields)

        query = f"""
        SELECT {field_str}
        FROM daily_data
        WHERE 1=1
        """
        params = {}

        if symbol:
            query += " AND symbol = :symbol"
            params['symbol'] = symbol
        if start_date:
            query += " AND trade_date >= :start_date"
            params['start_date'] = start_date
        if end_date:
            query += " AND trade_date <= :end_date"
            params['end_date'] = end_date

        query += " ORDER BY trade_date DESC"

        if limit:
            query += f" LIMIT {limit}"

        try:
            df = self._execute_query(query, params)
            if not df.empty:
                if 'trade_date' in df.columns:
                    df['trade_date'] = pd.to_datetime(df['trade_date'])
                    df = df.sort_values('trade_date')
            self.logger.info(f"æŸ¥è¯¢æ—¥çº¿æ•°æ®ï¼Œè¿”å›{len(df)}æ¡è®°å½•")
            return df
        except Exception as e:
            self.logger.error(f"æŸ¥è¯¢æ—¥çº¿æ•°æ®å¤±è´¥: {e}")
            return pd.DataFrame()

    def get_multiple_stocks(self,
                           symbols: List[str],
                           start_date: str,
                           end_date: str,
                           fields: List[str] = None) -> Dict[str, pd.DataFrame]:
        """
        æŸ¥è¯¢å¤šåªè‚¡ç¥¨æ•°æ®

        Args:
            symbols: è‚¡ç¥¨ä»£ç åˆ—è¡¨
            start_date: å¼€å§‹æ—¥æœŸ
            end_date: ç»“æŸæ—¥æœŸ
            fields: è¿”å›å­—æ®µåˆ—è¡¨

        Returns:
            Dict: è‚¡ç¥¨ä»£ç åˆ°DataFrameçš„æ˜ å°„
        """
        results = {}
        for symbol in symbols:
            df = self.get_daily_data(symbol, start_date, end_date, fields)
            if not df.empty:
                results[symbol] = df
        return results

    def get_data_statistics(self) -> Dict:
        """
        è·å–æ•°æ®ç»Ÿè®¡ä¿¡æ¯

        Returns:
            Dict: æ•°æ®ç»Ÿè®¡ä¿¡æ¯
        """
        stats = {}

        # è‚¡ç¥¨æ•°é‡ç»Ÿè®¡
        stock_query = """
        SELECT 
            COUNT(*) as total_stocks,
            COUNT(DISTINCT industry) as total_industries,
            exchange,
            COUNT(*) as count_by_exchange
        FROM stock_basic
        GROUP BY exchange
        """

        # æ—¥çº¿æ•°æ®ç»Ÿè®¡
        daily_query = """
        SELECT 
            COUNT(*) as total_records,
            MIN(trade_date) as earliest_date,
            MAX(trade_date) as latest_date,
            COUNT(DISTINCT symbol) as stocks_with_data
        FROM daily_data
        """

        try:
            # è‚¡ç¥¨ç»Ÿè®¡
            stock_stats = self._execute_query(stock_query)
            daily_stats = self._execute_query(daily_query)

            if not stock_stats.empty:
                stats['stock_basic'] = {
                    'total_stocks': int(stock_stats['total_stocks'].iloc[0]),
                    'total_industries': int(stock_stats['total_industries'].iloc[0]),
                    'exchange_distribution': stock_stats.set_index('exchange')['count_by_exchange'].to_dict()
                }
            else:
                stats['stock_basic'] = {
                    'total_stocks': 0,
                    'total_industries': 0,
                    'exchange_distribution': {}
                }

            if not daily_stats.empty:
                stats['daily_data'] = {
                    'total_records': int(daily_stats['total_records'].iloc[0]),
                    'earliest_date': str(daily_stats['earliest_date'].iloc[0]) if pd.notna(daily_stats['earliest_date'].iloc[0]) else None,
                    'latest_date': str(daily_stats['latest_date'].iloc[0]) if pd.notna(daily_stats['latest_date'].iloc[0]) else None,
                    'stocks_with_data': int(daily_stats['stocks_with_data'].iloc[0])
                }
            else:
                stats['daily_data'] = {
                    'total_records': 0,
                    'earliest_date': None,
                    'latest_date': None,
                    'stocks_with_data': 0
                }

            self.logger.info("æ•°æ®ç»Ÿè®¡æŸ¥è¯¢æˆåŠŸ")
            return stats

        except Exception as e:
            self.logger.error(f"æ•°æ®ç»Ÿè®¡æŸ¥è¯¢å¤±è´¥: {e}")
            return {}

    def get_stock_list(self) -> List[str]:
        """
        è·å–è‚¡ç¥¨ä»£ç åˆ—è¡¨

        Returns:
            List: è‚¡ç¥¨ä»£ç åˆ—è¡¨
        """
        query = "SELECT symbol FROM stock_basic ORDER BY symbol"
        try:
            df = self._execute_query(query)
            return df['symbol'].tolist()
        except Exception as e:
            self.logger.error(f"è·å–è‚¡ç¥¨åˆ—è¡¨å¤±è´¥: {e}")
            return []

    def get_trading_dates(self,
                         symbol: str,
                         start_date: str = None,
                         end_date: str = None) -> List[str]:
        """
        è·å–äº¤æ˜“æ—¥æœŸåˆ—è¡¨

        Args:
            symbol: è‚¡ç¥¨ä»£ç 
            start_date: å¼€å§‹æ—¥æœŸ
            end_date: ç»“æŸæ—¥æœŸ

        Returns:
            List: äº¤æ˜“æ—¥æœŸåˆ—è¡¨
        """
        query = """
        SELECT DISTINCT trade_date
        FROM daily_data
        WHERE symbol = :symbol
        """
        params = {'symbol': symbol}

        if start_date:
            query += " AND trade_date >= :start_date"
            params['start_date'] = start_date
        if end_date:
            query += " AND trade_date <= :end_date"
            params['end_date'] = end_date

        query += " ORDER BY trade_date"

        try:
            df = self._execute_query(query, params)
            return df['trade_date'].astype(str).tolist()
        except Exception as e:
            self.logger.error(f"è·å–äº¤æ˜“æ—¥æœŸå¤±è´¥: {e}")
            return []

    def close(self):
        """å…³é—­è¿æ¥ï¼ˆSQLAlchemyè‡ªåŠ¨ç®¡ç†ï¼‰"""
        # SQLAlchemyä¼šè‡ªåŠ¨ç®¡ç†è¿æ¥ï¼Œè¿™é‡Œä¸éœ€è¦æ‰‹åŠ¨å…³é—­
        pass

    def test_connection(self) -> bool:
        """æµ‹è¯•æ•°æ®åº“è¿æ¥"""
        try:
            with self.engine.connect() as conn:
                result = conn.execute(text("SELECT 1"))
                self.logger.info("æ•°æ®åº“è¿æ¥æµ‹è¯•æˆåŠŸ")
                return True
        except Exception as e:
            self.logger.error(f"æ•°æ®åº“è¿æ¥æµ‹è¯•å¤±è´¥: {e}")
            return False


# ==================== è¾…åŠ©å‡½æ•° ====================

def quick_test():
    """å¿«é€Ÿæµ‹è¯•å‡½æ•°"""
    print("ğŸ§ª å¿«é€Ÿæµ‹è¯•æŸ¥è¯¢å¼•æ“...")
    engine = QueryEngine()

    try:
        # æµ‹è¯•è¿æ¥
        if not engine.test_connection():
            print("âŒ æ•°æ®åº“è¿æ¥å¤±è´¥")
            return False

        print("âœ… æ•°æ®åº“è¿æ¥æˆåŠŸ")

        # è·å–ç»Ÿè®¡ä¿¡æ¯
        stats = engine.get_data_statistics()
        print(f"ğŸ“Š æ•°æ®ç»Ÿè®¡:")
        print(f"  è‚¡ç¥¨æ•°é‡: {stats.get('stock_basic', {}).get('total_stocks', 0)}")
        print(f"  æ—¥çº¿è®°å½•: {stats.get('daily_data', {}).get('total_records', 0)}")

        # è·å–è‚¡ç¥¨åˆ—è¡¨
        stocks = engine.get_stock_list()
        print(f"ğŸ“‹ è‚¡ç¥¨åˆ—è¡¨ ({len(stocks)} åª):")
        for i, stock in enumerate(stocks[:3]):
            print(f"  {i+1}. {stock}")
        if len(stocks) > 3:
            print(f"  ... ç­‰{len(stocks)}åªè‚¡ç¥¨")

        # æµ‹è¯•æŸ¥è¯¢æ•°æ®
        if stocks:
            df = engine.get_daily_data(stocks[0], limit=3)
            if not df.empty:
                print(f"\nğŸ“… {stocks[0]} æœ€è¿‘3ä¸ªäº¤æ˜“æ—¥æ•°æ®:")
                print(df[['trade_date', 'open', 'high', 'low', 'close', 'volume']].to_string())

        print("\nâœ… æŸ¥è¯¢å¼•æ“æµ‹è¯•å®Œæˆ!")
        return True

    except Exception as e:
        print(f"âŒ æµ‹è¯•å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()
        return False


if __name__ == "__main__":
    quick_test()